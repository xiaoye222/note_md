## ES6

### 变量定义

##### 1.let

声明变量
a.变量只在当前的代码块内有效
b.变量的声明不会提升
c.暂时性死区(避免变量的全局污染)
d.不允许重复声明

##### 2.const

声明常量
const具备let所具备的一切特性
a.声明之后不可以重新赋值
b.声明的同时必须初始化



### 解构赋值

为了简化提取信息的人物，ES6新增了解构（destructuring），这是一将一个**数据解耦分解成更小的部分**的过程

ES6 的解构实际使用的语法其实你早已熟悉，那就是**对象与数组的字面量语法**。

#### 对象解构

对象解构语法在赋值语句的左侧使用了对象字面量

```javascript
let node = {
    type: "Identifier"
    name: "foo"
};
let { type, name } = node;
console.log(type); // "Identifier"
console.log(name); // "foo"
```

在此代码中， node.type 的值被存储到 type 本地变量中， node.name 的值则存储到 name 变量中。type 与 name 标识符既**声明了本地变量**，也**读取了对象的相应属性值**。

不要遗忘初始化器当使用解构来配合 var 、 let 或 const 来声明变量时，必须提供**初始化器**（即**等号右边的值**）。下面的代码都会因为缺失初始化器而抛出错误：

```javascript
// 语法错误！
var { type, name };
// 语法错误！
let { type, name };
// 语法错误！
const { type, name };
```

const 总是要求有初始化器，即使没有使用解构的变量

var 与 let 则仅在使用解构时才作此要求

##### 解构赋值

以上对象解构示例都用于变量声明。不过，也**可以在赋值的时候使用解构**。例如，想在变量声明之后改变它们的值，如下所示

```javascript
let node = {
    type: "Identifier",
    name: "foo"
},
type = "Literal",
name = 5;
// 使用解构来分配不同的值
({ type, name } = node);
console.log(type); // "Identifier"
console.log(name); // "foo"
```

在本例中， type 与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 node 对象来更改这两个变量的值。

注意必须**用圆括号包裹**解构赋值语句，这是因为**暴露的花括号会被解析为代码块语句**，而**块语句不允许在赋值操作符（即等号）左侧出现**。圆括号标示了里面的花括号**并不是块语句、而应该被解释为表达式**，从而允许完成赋值操作。

**解构赋值表达式**的值**为表达式右侧（在 = 之后）的值**。也就是说在任何期望有个值的位置都可以使用**解构赋值表达式**。例如，传递值给函数：

```javascript
let node = {
    type: "Identifier",
    name: "foo"
},
type = "Literal",
name = 5;
function outputInfo(value) {
    console.log(value === node); // true
}
outputInfo({ type, name } = node);
console.log(type); // "Identifier"
console.log(name); // "foo"
```

outputInfo() 函数被使用一个解构赋值表达式进行了调用。该表达式计算结果为 node ，因为这就是表达式右侧的值。对 **type 与 name 的赋值正常进行**，同时 node 也被传入了 outputInfo() 函数。

当解构赋值表达式的右侧（ = 后面的表达式）的计算结果为 null 或 undefined 时， 会抛出错误。因为任何读取 null 或 undefined 的企图都会导致“运行时”错误（ runtime error ）。

##### 默认值

当使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为 undefined

可以选择性地定义一个默认值，以便在指定属性不存在时使用该值。若要这么做，需要在属性名后面添加一个等号并指定默认值，就像这样：

```javascript
let node = {
    type: "Identifier",
    name: "foo"
};
let { type, name, value = true } = node;
console.log(type); // "Identifier"
console.log(name); // "foo"
console.log(value); // true
```

在此例中，变量 value 被指定了一个默认值 true ，只有在 **node 的对应属性缺失**、或**对应的属性值为 undefined** 的情况下，该默认值才会被使用。由于此处不存在 node.value 属 性，变量 value 就使用了该默认值。

这种工作方式很像函数参数的默认值。

##### 赋值给不同的本地变量名

至此的每个解构赋值示例都使用了对象中的属性名作为本地变量的名称，例如，把 node.type 的值存储到 type 变量上。若想使用相同名称，这么做就没问题，但若你不想 呢？ ES6 有一个扩展语法，允许你在给本地变量赋值时使用一个不同的名称，而且该语法看 去就像是使用对象字面量的非简写的属性初始化。这里有个示例：

```javascript
let node = {
    type: "Identifier",
    name: "foo"
};
let { type: localType, name: localName } = node;
console.log(localType); // "Identifier"
console.log(localName); // "foo"
```

此代码使用了解构赋值来声明 localType 与 localName 变量，分别获得了 node.type 与 node.name 属性的值。 type: localType 这种语法表示要**读取名为 type 的属性**，并**把它的值存储在变量 localType** 上。

该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，则是名称在右边，需要进行值读取的位置则被放在了左边。 你也可以给变量别名添加默认值，依然是在本地变量名称后添加等号与默认值，例如：

```javascript
let node = {
    type: "Identifier"
};
let { type: localType, name: localName = "bar" } = node;
console.log(localType); // "Identifier"
console.log(localName); // "bar"
```

此处的 localName 变量拥有一个默认值 "bar" ，该变量最终被赋予了默认值，因为 node.name 属性并不存在。 到此为止，你已经看到如何处理属性值为基本类型值的对象的解构，而对象解构也可被用于从嵌套的对象结构（即：对象的属性可能还是一个对象）中提取属性值。

##### 嵌套的对象解构

使用类似于对象字面量的语法，可以深入到嵌套的对象结构中去提取你想要的数据。

```javascript
let node = {
    type: "Identifier",
    name: "foo",
    loc: {
      start: {
        line: 1,
        column: 1
        },
      end: {
        line: 1,
        column: 4
        }
    }
};
let { loc: { start }} = node;
console.log(start.line); // 1
console.log(start.column); // 1
```

本例中的解构模式使用了花括号，表示应当**下行到 node 对象的 loc 属性内部去寻找 start 属性**。

每当有一个冒号在解构模式中出现**，就意味着冒号之前的标识符代表**需要检查的位置**，而**冒号右侧则是赋值的目标**。**

**当冒号右侧存在花括号时，表示**目标被嵌套在对象的更深一层**中。

你还能更进一步，在对象的嵌套解构中同样能为本地变量使用不同的名称

```javascript
let node = {
    type: "Identifier",
    name: "foo",
    loc: {
        start: {
        line: 1,
        column: 1
        },
    end: {
        line: 1,
        column: 4
        }
    }
};
// 提取 node.loc.start
let { loc: { start: localStart }} = node;
console.log(localStart.line); // 1
console.log(localStart.column); // 1
```

在此版本的代码中， node.loc.start 的值被存储在一个新的本地变量 localStart 上，解构模式可以被嵌套在任意深度的层级，并且在每个层级的功能都一样。 对象解构十分强大并有很多可用形式，而数组解构则提供了一些独特的能力，用于提取数组中的信息。

##### 语法难点

使用嵌套的解构时需要小心，因为你可能无意中就创建了一个没有任何效果的语句。空白花括号在对象解构中是合法的，然而它不会做任何事。例如：

```javascript
// 没有变量被声明！ 
let { loc: {} } = node;
```

在此语句中并未声明任何变量绑定。由于花括号在右侧，loc 被作为需检查的位置来使用，而不会创建变量绑定。

这种情况仿佛是想用等号来定义一个默认值，但却被语法判断为想用冒号来定义一个位置。这种语法将来可能是非法的，然而现在它只是需要留意的一个疑难点。

#### 数组解构

数组解构的语法看起来与对象解构非常相似，只是将对象字面量替换成了数组字面量。数组解构时，解构作用在**数组内部的位置**上，而不是作用在对象的具名属性上

```javascript
let colors = [ "red", "green", "blue" ];
let [ firstColor, secondColor ] = colors;
console.log(firstColor); // "red"
console.log(secondColor); // "green"
```

此处数组解构从 colors 数组中取出了 "red" 与 "green" ，并将它们赋值给 fristColor 与 secondColor 变量。这些值被选择，是由于它们在数组中的位置，实际的变量名称是任意的（与位置无关）。任何没有在解构模式中明确指定的项都会被忽略。记住，**数组本身并没有以任何方式被改变**。

你也可以在解构模式中忽略一些项，并且只给感兴趣的项提供变量名。例如，若只想获取数 组中的第三个元素，那么不必给前两项提供变量名。以下展示了这种方式：

```javascript
let colors = [ "red", "green", "blue" ];
let [ , , thirdColor ] = colors;
console.log(thirdColor); // "blue"
```

此代码使用了解构赋值来获取 colors 的第三个项。模式中 thirdColor之前的逗号，是为数组前面的项提供的**占位符**。使用这种方法，你就可以轻易从数组任意位置取出值，而无须给其他项提供变量名。

##### 解构赋值

你可以在赋值表达式中使用数组解构，但是**与对象解构不同**，**不必将表达式包含在圆括号内**

##### 互换变量

```javascript
// 在 ES6 中互换值
let a = 1,
b = 2;
//注意;一定要写，否则报错 Cannot access 'b' before initialization 
//格式化插件格式化代码后发现b = 2[a, b] = [b, a]; 
[ a, b ] = [ b, a ];
console.log(a); // 2
console.log(b); // 1
```

本例中的数组解构赋值看起来如同镜像。赋值语句左侧（即等号之前）的解构模式正如其他数组解构的范例，右侧则是为了互换而临时创建的数组字面量。 b 与 a 的值分别被复制到临时数组的第一个与第二个位置，并对该数组进行解构，结果两个变量就互换了它们的值。

与对象解构赋值相同，若等号右侧的计算结果为 null 或 undefined ，那么数组解构赋 值表达式也会抛出错误。

##### 默认值

数组解构赋值同样允许在数组任意位置指定默认值。当指定位置的项不存在、或其值为 undefined ，那么该默认值就会被使用。例如：

```javascript
let colors = [ "red" ];
let [ firstColor, secondColor = "green" ] = colors;
console.log(firstColor); // "red"
console.log(secondColor); // "green"
```

此代码的 colors 数组只有一个项，因此没有能与 secondColor 匹配的项，又由于此处有个默认值， secondColor 的值就被设置为 "green" ，而不是 undefined 。

##### 嵌套的解构

与解构嵌套的对象相似，可以用类似的方式来解构嵌套的数组。在整个解构模式中插入另一个数组模式，解构操作就会下行到嵌套的数组中，就像这样：

```javascript
let colors = [ "red", [ "green", "lightgreen" ], "blue" ];
// 随后
let [ firstColor, [ secondColor ] ] = colors;
console.log(firstColor); // "red"
console.log(secondColor); // "green"
```

此处的 secondColor 变量指向了 colors 数组中的 "green" 值，该项被包含在第二个数组中，因此解构模式就要把 secondColor 包裹上方括号。与对象解构相似，你也能使用任意深度的数组嵌套。

##### 剩余项

第三章介绍过函数的剩余参数，而数组解构有个类似的、名为剩余项（ rest items ）的概念，它使用 ... 语法来**将剩余的项目**赋值给一个指定的变量，此处有个范例

```javascript
let colors = [ "red", "green", "blue" ];
let [ firstColor, ...restColors ] = colors;
console.log(firstColor); // "red"
console.log(restColors.length); // 2
console.log(restColors[0]); // "green"
console.log(restColors[1]); // "blue"
```

colors 数组的第一项被赋值给了 firstColor 变量，而剩余的则赋值给了一个新的 restColors 数组； restColors 数组则有两个项： "green" 与 "blue" 。

若要**取出特定项并要求保留剩余的值**，则剩余项是非常有用的，但它还有另一个有用的功能。 方便地克隆数组在 JS 中是个明显被遗漏的功能。在 ES5 中开发者往往使用的是一个简单的方式，也就是用 concat() 方法来克隆数组，例如：

```javascript
// 在 ES5 中克隆数组
var colors = [ "red", "green", "blue" ];
var clonedColors = colors.concat();
console.log(clonedColors); //"[red,green,blue]"
```

尽管 concat() 方法的本意是合并两个数组，但不使用任何参数来调用此方法，就会获得原 数组的一个克隆品。而在 ES6 中，你可以使用剩余项的语法来达到同样效果。实现如下

```javascript
// 在 ES6 中克隆数组
let colors = [ "red", "green", "blue" ];
let [ ...clonedColors ] = colors;
console.log(clonedColors); //"[red,green,blue]"
```

在本例中，剩余项被用于将 colors 数组的值复制到 clonedColors 数组中。虽然从感觉上 来说，使用这种技术未必让开发者复制数组的意图体现得比使用 concat() 方法更明显，但这依然是个值得关注的技巧。

剩余项必须是数组解构模式中**最后的部分**，之后不能再有逗号，否则就是语法错误。

#### 混合解构

对象与数组解构能被用在一起，以创建更复杂的解构表达式。在对象与数组混合而成的结构中，这么做便能准确提取其中你想要的信息片段。例如：

```javascript
let node = {
    type: "Identifier",
    name: "foo",
    loc: {
        start: {
        line: 1,
        column: 1
        },
    end: {
        line: 1,
        column: 4
        }
    },
    range: [0, 3]
};
let {
    loc: { start },
    range: [ startIndex ]
    } = node;
console.log(start.line); // 1
console.log(start.column); // 1
console.log(startIndex); // 0
```

此代码将 node.loc.start 与 node.range[0] 提取出来，并将它们的值分别存储到 start 与 startIndex 中。要记住解构模式中的 loc: 与 range: 只是对应于 node 对象中属性的位 置。混合使用对象与数组解构， node 的任何部分都能提取出来。

对于从 JOSN 配置结构中抽取数据来说，这种方法尤其有用，因为它不需要探索整个结构。

#### 参数解构

函数执行完返回值，

```javascript
function fn() {
    return 2;
}
let [y, x = fn()] = [1];
console.log(x);//2

function fn() {}
let [y, x = fn()] = [1];
console.log(x);//undefined
```

函数没有return log打印的就是undefined，有return，log打印的就是返回值

#### 字符串解构

字符串的属性、某些方法可以解构

```javascript
let { trim } = 'hello'
console.log(trim === String.prototype.trim)
// true

let { toString } = true
console.log(toString === Boolean.prototype.toString)
// true
```

#### 数字和布尔值解构

不具备迭代器，解构不会成功

```javascript
let [a, b, c] = true
console.log(a, b, c)
//true is not iterable
let {a,b,c} = 123
console.log(a,b,c)
//undefined undefined undefined
```

### 函数默认参数

**1、函数参数的默认值**

　　ES5中不能直接为函数的参数指定默认值，只能通过以下的变通方式：

　　![](C:\Users\刘颖\Pictures\笔记\es6函数默认参数1.png)

　　从上面的代码可以看出存在一个问题，当传入的参数为0或者false时，会直接取到后面的值，而不是传入的这个参数值。

　　那怎么解决呢？对于上图的代码，可以通过判断是否传入了num参数，没有就用默认值：

　![](C:\Users\刘颖\Pictures\笔记\es6函数默认参数2.png)

　　这种做法还是很麻烦的，而ES6则直接在参数定义里面设置函数参数的默认值，而且不用担心传入参数是0或者false会出错了

![](C:\Users\刘颖\Pictures\笔记\es6函数默认参数3.png)



### Promise

> 一个Promise指定一些稍后要执行的代码（像事件与回调函数一样）

Promise 是异步编程的一种**解决方案**，比传统的解决方案——回调函数和事件——更合理和更强大。
所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
从语法上说，Promise是一个**对象**，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。

#### Promise对象的特点

（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。

（2）**一旦状态改变，就不会再变**，**任何时候**都**可以得到这个结果**。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。**这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。**

#### Promise的缺点

1. 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
2. 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
3. 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

#### Promise对象的基本用法

ES6 规定，Promise对象是一个**构造函数**，用来生成Promise实例。
Promise构造函数接受**一个函数**作为参数，该函数的两个参数分别是**resolve**和**reject**。它们是**两个函数**，由 JavaScript 引擎提供，不用自己部署。



resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的**结果**，作为**参数**传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的**错误**，作为**参数**传递出去。

Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。

```javascript
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
```

then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是**可选**的，不一定要提供。这两个函数都接受**Promise对象传出的值**作为参数。

下面是一个Promise对象的简单例子。

```javascript
function timeout(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms, 'done');
  });
}
timeout(100).then((value) => {
  console.log(value);
});
```

上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。

Promise 新建后就会立即执行。

```javascript
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
```

上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。

#### resolve函数

将Promise对象的状态从“未完成”变为“成功”，在异步操作成功的时候调用，并将异步操作的结果，作为参数传递出去。

#### reject函数

将Promise对象的状态从“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

then方法指定的回调函数，在当前脚本所有的同步任务执行完才会执行。

如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。

发现reject方法的作用，等同于抛出错误

#### then()方法

它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。

then方法返回的是一个新的Promise实例。

采用链式的then，可以指定一组按照次序调用的回调函数。

#### promise的状态、状态的表现和变化，then和catch对状态的影响

**三种状态**

pending、resolved、rejected

pending--> resolved pending-->rejected 变化不可逆

初始化promise时，传入的函数会立刻被执行（同步里的）

**状态的表现**

pending状态，不会触发then和catch

resolved会触发后续的then回调函数？

rejected会触发后续的catch回调函数

立即resolved的Promise实在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。一般来说，调用resolve或rejecte以后，promise

的使命就完成了，后续操作应该放到then方法里面，而不该直接写在resolve或rejecte的后面，所以最好在它们前面加上return语句，后

面的语句就不会执行。

**then**

then方法的作用是为Promise实例添加状态改变时的回调函数，then方法返回的是一个新的Promise实例（不是原来的Promise实例）。

采用链式的then，可以指定一组按照次序调用的回调函数。这时前一个回调函数，有可能返回的还是一个promise对象(即有异步操作)，

这时后一个回调函数，就会等待该promise对象的状态发生变化，才会被调用。

#### Promise中的错误

Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，错误总是会被下一个catch语句捕获。

##### 与传统的try/catch代码块不同

如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应

##### Promise.all()

p的状态由p1、p2、p3决定，分成两种情况。
（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

#### done()

done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。

#### finally()

方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。



### async

一句话，async 函数就是 Generator 函数的语法糖。

async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行时，遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内部的语句。

> 所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是"重新调用"。

##### async与await

- async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
- 而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。
- 返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。
- 进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。

##### 语法

async函数返回的Promise对象，必须等到内部所有await命令的Promise对象执行完，才会发生状态改变。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。

##### async函数的用法

##### 注意点

只要一个`await`语句后面的Promise变为`reject`，那么整个`async`函数都会中断执行。

await命令后面的Promise对象，运行结果可能是rejected，所以最好把**await命令放在try...catch**代码块中。

多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发（用Promise.all()）

await命令只能用在async函数之中，如果用在普通函数，就会报错。

forEach 并发、同时，而不是继发，正确的写法是采用for循环。

如果确实希望多个请求并发执行，使用Promise.all方法。

##### 并发发出远程请求

虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用

了await，因此实现了按顺序输出。

##### forEach for...of循环 与async /await搭配使用注意点

如果需要并发，使用Promise.all方法

##### then和catch对状态的改变

then正常返回resolved，里面有报错则返回rejected

catch正常返回resolved，里面有报错则返回rejected

##### async和await语法

背景 异步回调callback hell

Promise then catch 链式调用，但是也基于回调函数

async await是同步语法，彻底消灭回调函数

执行await必须有async包裹

await后面可以跟一个promise对象，也可以跟async修饰的函数

##### async await和Promise的关系

执行async函数，返回的是Promise对象

await相当于Promise的then(await后面可以跟一个promise对象、数或者其他值、async函数的执行结果？？？) 处理成功的情况

try...catch可捕获异常，代替了Promise的catch 处理失败的情况

async、await是 消灭异步回调的终极武器

但和Promise并不互斥

相反，两者相辅相成

##### 异步的本质

async await是（从语法层面）消灭异步回调的终极武器（本质代码执行还是异步的）

js还是单线程，还是得有异步，还是得基于event loop

async await只是一个语法糖，但是这个糖很香

执行async函数，要立马执行里面的内容

await的后面，都可以看作是callback里的内容，即异步

类似 event loop，setTimeout(cba)

##### for...of

for ..in (以及forEach for）是常规的同步遍历

for...of 常用于异步的遍历



### Map

Map用来保存键值对，类似于字典类型。任意值（对象或者原始值）都可以作为一个键或者一个值。

上面代码原意是将一个DOM节点作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`element`被自动转为字符串`[object HTMLDivElement]`。

为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“**键值对**”的数据结构，Map比Object更合适。



Object本质上是键值对的集合（Hash结构），传统上只能用字符串当作键。

Map也是键值对的集合，但是键的范围不局限字符串，包括对象都可以当作键。

##### Map的参数

Map可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数值。

##### 注意点

只有对同一个对象的引用，Map结构才将其视为同一个键盘。Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键



##### Map的键

同理，同样的值的两个实例，在Map结构中被视为两个键。

```javascript
var map = new Map();

var k1 = ['a'];
var k2 = ['a'];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222
```

上面代码中，变量`k1`和`k2`的值是一样的，但是它们在Map结构中被视为两个键。

由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括`0`和`-0`。另外，虽然`NaN`不严格相等于自身，但Map将其视为同一个键。

##### Maps 和 Objects 用法比较

Object对象的键只能是字符串或者 Symbols类型，但Map对象的键可以是任意值。

Map 中的键值是有序的（FIFO 原则），而添加到Object中的键则不是。

Map 的键值对个数可以根据 size 属性获取，而 Object 的键值对个数只能手动计算。

Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。

##### 与其他数据结构的互相转换

**（1）Map转为数组**

Map转为数组最方便的方法，就是使用扩展运算符（...）。

```javascript
let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
```

**（2）数组转为Map**

将数组转入Map构造函数，就可以转为Map。

```javascript
new Map([[true, 7], [{foo: 3}, ['abc']]])
// Map {true => 7, Object {foo: 3} => ['abc']}
```

**（3）Map转为对象**

如果所有Map的键都是字符串，它可以转为对象。

```javascript
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToObj(myMap)
// { yes: true, no: false }
```

**（4）对象转为Map**

```javascript
function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}

objToStrMap({yes: true, no: false})
// [ [ 'yes', true ], [ 'no', false ] ]
```

**（5）Map转为JSON**

Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。

```javascript
function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap)
// '{"yes":true,"no":false}'
```

另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。

```javascript
function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
mapToArrayJson(myMap)
// '[[true,7],[{"foo":3},["abc"]]]'
```

**（6）JSON转为Map**

JSON转为Map，正常情况下，所有键名都是字符串。

```javascript
function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap('{"yes":true,"no":false}')
// Map {'yes' => true, 'no' => false}
```

但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。

```javascript
function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
// Map {true => 7, Object {foo: 3} => ['abc']}
```



##### WeakMap

结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制

WeakMap应用的典型场合就是DOM节点作为键名，另一个用处是部署私有属性。



### Set

Set对象用来存储任意类型的唯一值

特殊情况：

1、+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；

2、undefined 与 undefined 是恒等的，所以不重复。

3、NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个。



向Set加入值，不会发生类型转换，Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（=），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身Set内部，两个对象总是不相等的。



##### 去除数组的重复成员

[...new Set(array)]

向Set加入值的时候，不会发生类型转换，所以`5`和`"5"`是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（`===`），主要的区别是`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。



另外，两个对象总是不相等的。

```javascript
let set = new Set();

set.add({});
set.size // 1

set.add({});
set.size // 2
```

上面代码表示，由于两个空对象不相等，所以它们被视为两个值。



##### 方法

- `add(value)`：添加某个值，返回Set结构本身。
- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
- `clear()`：清除所有成员，没有返回值。



判断是否包括一个键上，Object与Set写法不同

```javascript
// 对象的写法
var properties = {
  'width': 1,
  'height': 1
};

if (properties[someName]) {
  // do something
}

// Set的写法
var properties = new Set();

properties.add('width');
properties.add('height');

if (properties.has(someName)) {
  // do something
}
```

`Array.from`方法可以将Set结构转为数组。

```javascript
var items = new Set([1, 2, 3, 4, 5]);
var array = Array.from(items);
```

这就提供了去除数组重复成员的另一种方法。

```javascript
function dedupe(array) {
  return Array.from(new Set(array));
}

dedupe([1, 1, 2, 3]) // [1, 2, 3]
```



##### 遍历操作

Set结构的实例有四个遍历方法，可以用于遍历成员。

- `keys()`：返回键名的遍历器
- `values()`：返回键值的遍历器
- `entries()`：返回键值对的遍历器
- `forEach()`：使用回调函数遍历每个成员

`Set`的**遍历顺序就是插入顺序**。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。

应用：使用Set保存回调函数列表，调用时保证添加顺序调用



**（1）`keys()`，`values()`，`entries()`**

`key`方法、`value`方法、`entries`方法返回的都是遍历器对象。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以`key`方法和`value`方法的行为完全一致。

**（3）遍历的应用**

扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于Set结构。

```javascript
let set = new Set(['red', 'green', 'blue']);
let arr = [...set];
// ['red', 'green', 'blue']
```

扩展运算符和Set结构相结合，就可以去除数组的重复成员。

```javascript
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
```

而且，数组的`map`和`filter`方法也可以用于Set了。

```javascript
let set = new Set([1, 2, 3]);
set = new Set([...set].map(x => x * 2));
// 返回Set结构：{2, 4, 6}

let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x => (x % 2) == 0));
// 返回Set结构：{2, 4}
```

因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。

```javascript
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}

// 差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}
```

如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用`Array.from`方法。

```javascript
// 方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val => val * 2));
// set的值是2, 4, 6

// 方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val => val * 2));
// set的值是2, 4, 6
```

上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。



##### 常见应用

Set和扩展运算符 实现并集/交集/差集

##### WeakSet

成员只能是对象，不能是其他类型的值
WeakSet中的对象都是弱引用。无法引用weakset的成员，不可遍历weakset

应用：WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。



### ES6模块化

> 在之前的javascript中是没有模块化概念的。如果要进行模块化操作，需要引入第三方的类库。随着技术的发展，前后端分离，前端的业务变的越来越复杂化。直至ES6带来了模块化，才让javascript第一次支持了module。ES6的模块化分为导出（export）与导入（import）两个模块。

ES6 模块的设计思想，是**尽量的静态化**，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。

```javascript
// CommonJS模块
let { stat, exists, readFile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;
```

上面代码的实质是整体加载`fs`模块（即加载`fs`的所有方法），生成一个对象（`_fs`），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

ES6 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。

```javascript
// ES6模块
import { stat, exists, readFile } from 'fs';
```

上面代码的实质是从`fs`模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。

由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。

除了静态加载带来的各种好处，ES6 模块还有以下好处。

- 不再需要`UMD`模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
- 将来浏览器的新 API 就能用模块格式提供，不再必要做成全局变量或者`navigator`对象的属性。
- 不再需要对象作为命名空间（比如`Math`对象），未来这些功能可以通过模块提供。



模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。

#### export命令

需要特别注意的是，`export`命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。

一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。

```javascript
// profile.js
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;
```

上面代码是`profile.js`文件，保存了用户信息。ES6将其视为一个模块，里面用`export`命令对外部输出了三个变量。

`export`的写法，除了像上面这样，还有另外一种。

```javascript
// profile.js
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;

export {firstName, lastName, year};
```

上面代码在`export`命令后面，使用**大括号**指定所要输出的一组变量。它与前一种写法（直接放置在`var`语句前）是等价的，但是应该**优先考虑**使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。

export命令除了输出变量，还可以输出函数或类（class）。

```javascript
export function multiply(x, y) {
  return x * y;
};
```

上面代码对外输出一个函数`multiply`。

通常情况下，`export`输出的变量就是本来的名字，但是可以使用`as`关键字重命名。

```javascript
function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
```

上面代码使用`as`关键字，重命名了函数`v1`和`v2`的对外接口。重命名后，`v2`可以用不同的名字输出两次。

需要特别注意的是，`export`命令**规定的是对外的接口，必须与模块内部的变量建立一一对应关系**。

```javascript
// 报错
export 1;

// 报错
var m = 1;
export m;
```

上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量`m`，还是直接输出1。`1`只是一个值，不是接口。正确的写法是下面这样。

```javascript
// 写法一
export var m = 1;

// 写法二
var m = 1;
export {m};

// 写法三
var n = 1;
export {n as m};
```

上面三种写法都是正确的，规定了对外的接口`m`。其他脚本可以通过这个接口，取到值`1`。它们的实质是，在**接口名与模块内部变量之间，建立了一一对应的关系**。

同样的，`function`和`class`的输出，也必须遵守这样的写法。

```javascript
// 报错
function f() {}
export f;

// 正确
export function f() {};

// 正确
function f() {}
export {f};
```

另外，`export`语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

```javascript
export var foo = 'bar';
setTimeout(() => foo = 'baz', 500);
```

上面代码输出变量`foo`，值为`bar`，500毫秒之后变成`baz`。



这一点与CommonJS规范完全不同。**CommonJS模块**输出的是**值的缓存**，**不存在动态更新**。

最后，`export`命令可以出现在模块的任何位置，只要处于模块顶层就可以。

如果处于块级作用域内，就会报错，下一节的`import`命令也是如此。

这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。

```javascript
function foo() {
  export default 'bar' // SyntaxError
}
foo()
```

上面代码中，`export`语句放在函数之中，结果报错。



#### import命令

使用`export`命令定义了模块的对外接口以后，其他 JS 文件就可以通过`import`命令加载这个模块。

```javascript
// main.js
import {firstName, lastName, year} from './profile';

function setName(element) {
  element.textContent = firstName + ' ' + lastName;
}
```

上面代码的`import`命令，用于加载`profile.js`文件，并从中输入变量。`import`命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（`profile.js`）对外接口的名称相同。

如果想为输入的变量重新取一个名字，`import`命令要使用`as`关键字，将输入的变量重命名。

```javascript
import { lastName as surname } from './profile';
```

`import`后面的`from`指定模块文件的位置，可以是相对路径，也可以是绝对路径，`.js`路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。

```javascript
import {myMethod} from 'util';
```

上面代码中，`util`是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。

注意，`import`命令具有提升效果，会提升到整个模块的头部，首先执行。

```javascript
foo();

import { foo } from 'my_module';
```

上面的代码不会报错，因为`import`的执行早于`foo`的调用。

这种行为的本质是，`import`命令是编译阶段执行的，在代码运行之前。

由于`import`是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。

```javascript
// 报错
import { 'f' + 'oo' } from 'my_module';

// 报错
let module = 'my_module';
import { foo } from module;

// 报错
if (x === 1) {
  import { foo } from 'module1';
} else {
  import { foo } from 'module2';
}
```

上面三种写法都会报错，因为它们用到了表达式、变量和`if`结构。在静态分析阶段，这些语法都是没法得到值的。



#### 模块的整体加载

除了指定加载某个输出值，还可以使用整体加载，即用星号（`*`）指定一个对象，所有输出值都加载在这个对象上面。

#### export default 命令 

从前面的例子可以看出，使用`import`命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。

但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。

为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到`export default`命令，为模块指定默认输出。

```javascript
// export-default.js
export default function () {
  console.log('foo');
}
```

上面代码是一个模块文件`export-default.js`，它的默认输出是一个函数。

其他模块加载该模块时，`import`命令可以为该匿名函数指定任意名字。

```javascript
// import-default.js
import customName from './export-default';
customName(); // 'foo'
```

上面代码的`import`命令，可以用任意名称指向`export-default.js`输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时`import`命令后面，**不使用大括号**。

`export default`命令用在非匿名函数前，也是可以的。

```javascript
// export-default.js
export default function foo() {
  console.log('foo');
}

// 或者写成

function foo() {
  console.log('foo');
}

export default foo;
```

上面代码中，`foo`函数的函数名`foo`，在模块外部是无效的。加载的时候，视同匿名函数加载。

下面比较一下默认输出和正常输出。

```javascript
// 第一组
export default function crc32() { // 输出
  // ...
}

import crc32 from 'crc32'; // 输入

// 第二组
export function crc32() { // 输出
  // ...
};

import {crc32} from 'crc32'; // 输入
```

第一组是使用`export default`时，对应的`import`语句不需要使用大括号；

第二组是不使用`export default`时，对应的`import`语句需要使用大括号。

`export default`命令用于指定模块的默认输出。

显然，一个模块只能有一个默认输出，因此`export default`命令只能使用一次。所以，`import`命令后面才不用加大括号，因为只可能对应一个方法。

本质上，`export default`就是输出一个叫做`default`的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。

```javascript
// modules.js
function add(x, y) {
  return x * y;
}
export {add as default};
// 等同于
// export default add;

// app.js
import { default as xxx } from 'modules';
// 等同于
// import xxx from 'modules';
```

正是因为`export default`命令其实只是输出一个叫做`default`的变量，所以它后面不能跟变量声明语句。

```javascript
// 正确
export var a = 1;

// 正确
var a = 1;
export default a;

// 错误
export default var a = 1;
```

上面代码中，`export default a`的含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。



有了`export default`命令，输入模块时就非常直观了，以输入 lodash 模块为例。

```javascript
import _ from 'lodash';
```

如果想在一条`import`语句中，同时输入默认方法和其他变量，可以写成下面这样。

```javascript
import _, { each } from 'lodash';
```

对应上面代码的`export`语句如下。

```javascript
export default function (obj) {
  // ···
}
export function each(obj, iterator, context) {
  // ···
}
export { each as forEach };
```

上面代码的最后一行的意思是，暴露出`forEach`接口，默认指向`each`接口，即`forEach`和`each`指向同一个方法。

如果要输出默认的值，只需将值跟在`export default`之后即可。

```javascript
export default 42;
```

`export default`也可以用来输出类。

```javascript
// MyClass.js
export default class { ... }

// main.js
import MyClass from 'MyClass';
let o = new MyClass();
```



### 迭代器 遍历器（指针对象）

是一种机制，是一种接口，为不同的数据结构提供统一的访问机制。

任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）

#### 概念

JavaScript 原有的表示“集合”的数据结构，主要是**数组**（Array）和**对象**（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。

这样就需要一种统一的**接口机制**，来处理所有不同的数据结构

遍历器（Iterator）就是这样一种**机制**。它是一种**接口**，为各种不同的数据结构**提供统一的访问机制**。任何数据结构只要部署 Iterator 接口，就可以**完成遍历操作**（即依次处理该数据结构的所有成员）。



#### 作用

为各种数据结构，提供一个统一的、简便的访问接口；

使得数据结构的成员能够**按某种次序排列**；

ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。

把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象

#### Iterator的遍历过程

（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。

（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。

（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。

每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。

#### Symbol.iterator

是遍历器生成函数

凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。

#### 目的

为所有数据结构，提供了一种统一的访问机制，即for...of循环

#### 原生具备Iterator接口的数据结构

数组

类数组对象

Set和Map结构

##### 给对象部署iterator接口

参考链接有

#### 调用遍历器接口的场合

解构赋值

扩展运算符（只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组）

搭配for...of循环遍历

数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。

for...of

Array.from()

Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）

Promise.all()

Promise.race()

### for循环

#### for in /for of / forEach的区别

##### for in

遍历数组或者对象的属性，遍历的是对象的属性名，而非属性值

可遍历的为对象的可遍历属性的属性名

不但把自身的属性名遍历处理啊，还将**原型链上的属性**遍历出来（对象本身及其所有可遍历属性的属性名）

数组的键名为数字，但是for…in循环的时候是以字符串作为键名，如"1"、"2"、"3"等。

某些情况下，for…in循环会以任意顺序遍历键名

###### for in的缺点

数组的键名是数字，但是for...in循环是以字符串作为键名，"0","1","2"等

for in不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键

```js
Object.prototype.say="cgl";   // 修改Object.prototype  
    var person ={ age: 18 };
    for (var key in person) {
        console.log(key, person[key]);//这里用person.key得不到对象key的值，用person[key] 或者 eval("person."+key);
    }   //结果： age 18 
                say cgl

```

解决方案

只遍历对象自身的属性，而不遍历继承于原型链上的属性，使用hasOwnProperty 方法过滤

```js
Object.prototype.say="cgl";
    var person ={
        age: 18
    };
    for (var key in person) {
        if(person.hasOwnProperty(key)){
            console.log(key, eval("person."+key));
        }
    }  

```

Object.keys() 方法会返回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。返回值是这个对象的所有可枚举属性组成的字符串数组。

```js
Object.prototype.say="cgl";
var person ={ age: 18};
console.log(Object.keys(person));//结果  ["age"] 
```

某些情况下，for in循环会以任何顺序遍历键名

> for...in是为遍历对象而设计，不适用于遍历数组



只能获得键名，不能直接获得键值

```js
var arr = ['a', 'b', 'c', 'd']; 

 //for in 
for (let a in arr) {  
	console.log(a); // 0 1 2 3 
} 

// for of
for (let a of arr) {  
	console.log(a); // a b c d 
} 
```





##### for of

ES6中新引入的语法，用于遍历可迭代的对象（字符串String，数组Array，集合Set，字典Map，arguments，DOM NodeList对象

用于遍历**对象本身**的元素

**只循环集合本身**的元素



###### for of的优点

和for in一样简洁，还没它的缺点

不同于for Each，可以与break continue和return配合时候用

提供遍历所有数据结构的统一接口操作

```js
let arr = [3, 5, 7]; 
arr.foo = 'hello'; 

for (let i in arr) { 
	console.log(i); // "0", "1", "2", "foo" 
} 

for (let i of arr) { 
	console.log(i); // "3", "5", "7"  for...of循环调用遍历器接口，数据的遍历器接口只返回具有数组索引的属性
}
```



###### for of遍历Set和Map

遍历的顺序是按照各个成员被添加进数据结构的顺序

Set结构遍历时，返回的是一个值

Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。

###### 类数组对象

不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。

###### 对象

普通对象，for...of结构不能直接使用，会报错，必须部署iterator接口后才能使用。
此时for...in循环依然可以遍历键名

###### 解决方案

看参考链接 iterator和for...of循环，普通对象使用for...of遍历





##### forEach

数组自带方法，没有办法与break/continue以及return配合使用





### Proxy与Reflect

#### Proxy 

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。

```javascript
var proxy = new Proxy(target, handler);
```

Proxy 对象的所有用法，都是上面这种形式，不同的只是`handler`参数的写法。其中，`new Proxy()`表示生成一个`Proxy`实例，`target`参数表示所要拦截的目标对象，`handler`参数也是一个对象，用来定制拦截行为。

##### Proxy支持的拦截操作

对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。

**（1）get(target, propKey, receiver)**

拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。

最后一个参数`receiver`是一个对象，可选，参见下面`Reflect.get`的部分。

**（2）set(target, propKey, value, receiver)**

拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。

**（3）has(target, propKey)**

拦截`propKey in proxy`的操作，以及对象的`hasOwnProperty`方法，返回一个布尔值。

**（4）deleteProperty(target, propKey)**

拦截`delete proxy[propKey]`的操作，返回一个布尔值。

**（5）ownKeys(target)**

拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`，返回一个数组。该方法返回对象所有自身的属性，而`Object.keys()`仅返回对象可遍历的属性。

**（6）getOwnPropertyDescriptor(target, propKey)**

拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。

**（7）defineProperty(target, propKey, propDesc)**

拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。

**（8）preventExtensions(target)**

拦截`Object.preventExtensions(proxy)`，返回一个布尔值。

**（9）getPrototypeOf(target)**

拦截`Object.getPrototypeOf(proxy)`，返回一个对象。

**（10）isExtensible(target)**

拦截`Object.isExtensible(proxy)`，返回一个布尔值。

**（11）setPrototypeOf(target, proto)**

拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。

如果目标对象是函数，那么还有两种额外操作可以拦截。

**（12）apply(target, object, args)**

拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。

**（13）construct(target, args)**

拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。

##### this 问题

虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的`this`关键字会指向 Proxy 代理。



#### Reflect

反射是一个非常有用的集合，囊括了所有JavaScript引擎内部专有的"内部方法 "，现在被暴露为了一个单一、方便的对象 —— Reflect。

为什么不直接将内置方法绑定到 Object 上呢？就像 `Object.keys`、`Object.getOwnPropertyNames` 这样。

- 反射拥有的方法不仅针对于 Object，还可能**针对于函数**，例如 `Reflect.apply`，毕竟调用 `Object.apply(myFunction)` 看起来太怪了。  
- 用一个单一对象贮存内置方法能**保持 JavaScript 其余部分的纯净性**，这要优于将反射方法通过点操作符挂载到构造函数或者原型上，更要优于直接使用全局变量。 
- `typeof`、`instanceof` 以及 `delete` 已经作为反射运算符存在了 —— 为此添加同样功能的新关键字将会加重开发者的负担，同时，对于向后兼容性也是一个梦魇，并且会让 JavaScript 中的保留字数量急速膨胀



不是构造函数，所以创建时不是用new来进行创造。

##### Reflect设计目的

（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。

（2） 修改某些Object方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`。

（3） 让`Object`操作都变成函数行为。某些`Object`操作是命令式，比如`name in obj`和`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为。

（4） `Reflect`对象的方法与`Proxy`对象的方法一一对应，只要是`Proxy`对象的方法，就能在`Reflect`对象上找到对应的方法。这就让`Proxy`对象可以方便地调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。也就是说，不管`Proxy`怎么修改默认行为，**总可以在`Reflect`上获取默认行为**。

##### Reflect对象的方法

**（1）Reflect.get(target, name, receiver)**

查找并返回`target`对象的`name`属性，如果没有该属性，则返回`undefined`。

如果`name`属性部署了读取函数，则读取函数的`this`绑定`receiver`。

```javascript
var obj = {
  get foo() { return this.bar(); },
  bar: function() { ... }
};

// 下面语句会让 this.bar()
// 变成调用 wrapper.bar()
Reflect.get(obj, "foo", wrapper);
```

**（2）Reflect.set(target, name, value, receiver)**

设置`target`对象的`name`属性等于`value`。如果`name`属性设置了赋值函数，则赋值函数的`this`绑定`receiver`。

**（3）Reflect.has(obj, name)**

等同于`name in obj`。

**（4）Reflect.deleteProperty(obj, name)**

等同于`delete obj[name]`。

**（5）Reflect.construct(target, args)**

等同于`new target(...args)`，这提供了一种不使用`new`，来调用构造函数的方法。

**（6）Reflect.getPrototypeOf(obj)**

读取对象的`__proto__`属性，对应`Object.getPrototypeOf(obj)`。

**（7）Reflect.setPrototypeOf(obj, newProto)**

设置对象的`__proto__`属性，对应`Object.setPrototypeOf(obj, newProto)`。

**（8）Reflect.apply(fun,thisArg,args)**

等同于`Function.prototype.apply.call(fun,thisArg,args)`。一般来说，如果要绑定一个函数的this对象，可以这样写`fn.apply(obj, args)`，但是如果函数定义了自己的`apply`方法，就只能写成`Function.prototype.apply.call(fn, obj, args)`，采用Reflect对象可以简化这种操作。

另外，需要注意的是，`Reflect.set()`、`Reflect.defineProperty()`、`Reflect.freeze()`、`Reflect.seal()`和`Reflect.preventExtensions()`返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。

```javascript
// 失败时抛出错误
Object.defineProperty(obj, name, desc);
// 失败时返回false
Reflect.defineProperty(obj, name, desc);
```

上面代码中，`Reflect.defineProperty`方法的作用与`Object.defineProperty`是一样的，都是为对象定义一个属性。但是，`Reflect.defineProperty`方法失败时，不会抛出错误，只会返回`false`。



### 数组扩展

#### 扩展运算符(对象、字符串都能用)

扩展运算符（spread）是三个点（...）。它好比rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列

##### 一般用法

```javascript
console.log(...[1, 2, 3]) // 1 2 3
let arr = ['a', 'b', 'c']
let [...test] = arr
console.log(test)//[ 'a', 'b', 'c' ]

let {...obj } = { name: 'tom', age: 12 }
console.log(obj)//{ name: 'tom', age: 12 }
```

##### 函数的调用(使用频率蛮高)

```javascript
let test = (a, b, c) => {
    console.log(a, b, c)
}
let arr = [1, 2, 3]
test(arr)//[ 1, 2, 3 ] undefined undefined 把arr当做一个整体给a了，b和c得到的值是undefined
test(...arr)//1 2 3 把当前的数组进行了解构，把123单抛出来，分别赋给a,b,c
```

##### 将字符串转换为数组

```javascript
let str="hello"
console.log([...str])
//[ 'h', 'e', 'l', 'l', 'o' ]
```

##### 对象中用...(扩展运算符)

```javascript
let obj={
    name:'tom',
    age:12
}

let obj2 = {
    ...obj,
    gender:'male'
}
console.log(obj2)
//{ name: 'tom', age: 12, gender: 'male' } 相当于obj2中也有了obj的属性
```

#### Array.from() 方法

用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）

##### 类数组对象使用（array-like object）

```javascript
let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 };
console.log(Array.from(arrayLike))
//[ 'a', 'b', 'c' ]
```

##### 拥有迭代器的数据

只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组

```javascript
// 拥有迭代器的数据
console.log(Array.from('hello'))
//[ 'h', 'e', 'l', 'l', 'o' ]
```

#### Array.of()

用于将一组值转换为数组。

```javascript
let arr = new Array(1, 2, 'a', true)
console.log(arr)//[ 1, 2, 'a', true ]   ES5中的方法
console.log(Array.of(3, 4, 'b', false))//[ 3, 4, 'b', false ] 使用Arrry.of()实现同样的功能
```

这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。

```javascript
let arr = new Array(3)
console.log(arr)//[ <3 empty items> ]
console.log(Array.of(3, 'a', false))//[ 3, 'a', false ]
console.log(Array.of(3))//[ 3 ]
```

#### 数组实例的find()

- 只返回一个符合条件的**值**，如果没有符合条件的，返回**undefined**
- 返回的是当前的数据
- find()接受一个回调函数作为参数
- 回调函数的参数（当前值，当前所处的位置，原数组） 这边都是形参，叫什么无所谓

```javascript
let arr = [5, 6, 3, 9, 1]
//希望找到里面大于5的数据
let result = arr.find((item, index, arr) => {
    return item > 5;
});
console.log(result);
//6
```

#### 数组实例的findIndex()

- 数组实例的findIndex方法的用法与find方法非常类似
- 返回第一个符合条件的数组成员的**位置**
- 如果所有成员都不符合条件，则返回**-1**

```javascript
let arr = [5, 6, 3, 9, 1]
let  result2  =  arr.findIndex((item,  index,  arr)  =>  {  
    return  item  >  5;
});
console.log(result2);
//1
```

#### 数组实例的fill()

- fill方法使用给定值，填充一个数组
- 改变原数组

```javascript
let arr = [5, 6, 3, 9, 1]
let res = arr.fill(10);
console.log(res);
console.log(arr === res);
//[ 10, 10, 10, 10, 10 ]
//true
```

#### 数组实例的entries(),keys(),values()

- 都用于遍历数组，都返回一个遍历器对象

```javascript
let arr = [23, 45, 67, 1, 4, 89]
let keys = arr.keys();
let values = arr.values();
let entries = arr.entries();
console.log(keys);
console.log(values);
console.log(entries);
//打印结果：
//Object [Array Iterator] {}
//Object [Array Iterator] {}
//Object [Array Iterator] {}
```

- 可以用**for...of**循环进行遍历

##### keys()

```javascript
let arr = [23, 45, 67, 1, 4, 89]
let keys = arr.keys();
for (var key of keys) {
    console.log(key);
}
//打印结果： 索引
0
1
2
3
4
5
let arr = [23, 45, 67, 1, 4, 89]
let keys = arr.keys();
for (var key of keys) {
    console.log(keys[key]);
}
//打印结果：  数组不是对象，拿不到键名
undefined
undefined
undefined
undefined
undefined
undefined
```

##### values()

```javascript
let arr = [23, 45, 67, 1, 4, 89]
let values = arr.values();
for (var value of values) {
    console.log(value);
}
//打印结果：
23
45
67
1
4
89
```

##### entries()

```javascript
let arr = [23, 45, 67, 1, 4, 89]
let entries = arr.entries();
for (var en of entries) {
    console.log(en);
}
//打印结果：
[ 0, 23 ]
[ 1, 45 ]
[ 2, 67 ]
[ 3, 1 ]
[ 4, 4 ]
[ 5, 89 ]
```

- keys()是对键名的遍历，数组中是索引，values()是对键值的遍历，entries()是对键值对的遍历

#### 比较for...in与for...of的使用

##### 数组

for...in可以遍历数组,并且拿到的是索引

```javascript
let arr = [31, 22, 'amo', 95, 12]
for (let i in arr) {
    console.log(i)
}
打印结果：
0
1
2
3
4
```



for...of遍历数组，拿到的是数组项

```javascript
let arr = [31, 22, 'amo', 95, 12]
for (let i of arr) {
    console.log(i)
}
打印结果：
31
22
amo
95
12
```



##### 对象

for...in拿到对象的属性名

```javascript
for (let i in obj) {
    console.log(i)
}
打印结果：
name
age
```



for...of不能遍历对象，会报错(因为普通对象没有迭代器)

```javascript
let obj = {
        name: 'tom',
        age: 12
    }
for (let i of obj) {
    console.log(i)
}
打印结果：
obj is not iterable
```



#### 数组实例的 includes()

该方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法，浏览器对es6的支持还不够好，用Babel将ES6转为ES5

```javascript
[1, 2, 3].includes(2)       // true 
[1, 2, 3].includes(4)       // false 
[1, 2, NaN].includes(NaN)   // true
```





### 对象扩展

#### 属性初始化器的速记法

- 消除对象名称与本地变量的重复
- 当对象的一个属性名称与本地变量名相同时，可以简单书写名称而省略冒号和值

当对象字面量中的属性只有名称时， JS 引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。

#### 方法简写

让你在对象字面量中定义方法时能省略冒号和 function 关键字， 从而减少输入的字符数

ES6改进了**为对象字面量方法赋值**的语法。在 ES5 及更早版本中，你必须指定一个名称并用完整的函数定义来为对象添加方法，如下：

```javascript
var person = {
name: "Nicholas",
sayName: function() {
console.log(this.name);
    }
};
```

通过**省略冒号与 function 关键字**； ES6 将这个语法变得更简洁，这意味着可以这样重写上个例子：

```javascript
var person = {
name: "Nicholas",
sayName() {
console.log(this.name);
    }
};
```

这种速记语法也被称为**方法简写语法**（ concise method syntax ），与上例一样在 person 对象中创建了一个方法。 sayName() 属性被一个**匿名函数**所赋值，并且具备 ES5 的 sayName() 方法的所有特征。

有一点区别是：**方法简写**能使用 **super** ，而**非简写的方法则不能**

**使用方法简写速记法创建的方法**，其 name 属性（名称属性）**就是括号之前的名称**。上面这个例子中， person.sayName() 的名称属性就是 "sayName" 。

```javascript
var obj = {
  age: 12,
  fun: function() {
  console.log("test");
  }
}
console.log(obj.fun.name);//fun


var obj1 = {
    age: 12,
    fun() {
        console.log("test");
    }
}
console.log(obj1.fun.name);//fun

var obj1 = {
    age: 12,
    test: function fun() {
        console.log("test");
    }
}

console.log(obj1.test.name);//funs
```

#### 需计算属性名 允许将非字面量的值指定为属性的名称

在 ES5 及更早版本中，对象实例能使用“需计算的属性名”，只要用**方括号表示法**来代替小数点表示法即可。方括号允许你**将变量或字符串字面量**指定为属性名，而在字符串中允许存在作为标识符时会导致语法错误的特殊字符。这里有个范例：

```javascript
var person = {},
lastName = "last name";
person["first name"] = "Nicholas";
person[lastName] = "Zakas";
console.log(person["first name"]); // "Nicholas"
console.log(person[lastName]); // "Zakas"
```

lastName 变量已被赋值为 "last name" ，因此该例中两个属性名都包含了**空格**，这样就**无法用小数点表示法**来引用它们了。然而，**方括号表示法**允许**将任意字符串用作属性名**，这样 "first name" 与 "last name" 属性就能分别被赋值为 "Nicholas" 与 "Zakas" 。

此外，你可以在对象字面量中将字符串字面量直接用作属性，就像这样

```javascript
var person = { "first name": "Nicholas" };
console.log(person["first name"]); // "Nicholas"
```

这种模式要求**属性名事先已知**、并且**能用字符串字面量**表示。然而，若属性名被包含在变量中（就像前面例子中的 "first name" ），或者必须通过计算才能获得，那么在 ES5 的对象字面量中就无法定义这种属性。

在 ES6 中，**需计算属性名**是**对象字面量语法**的一部分，它用的也是方括号表示法，与此前在对象实例上的用法一致。例如：

```javascript
var lastName = "last name";
var person = {
"first name": "Nicholas",
[lastName]: "Zakas"
};
console.log(person["first name"]); // "Nicholas"
console.log(person[lastName]); // "Zakas"
```

对象字面量内的方括号表明该**属性名需要计算**，其**结果是一个字符串**。这意味着其中**可以包含表达式**，像下面这样

```javascript
var suffix = " name";
var person = {
["first" + suffix]: "Nicholas",
["last" + suffix]: "Zakas"
};
console.log(person["first name"]); // "Nicholas"
console.log(person["last name"]); // "Zakas"
```

这些属性名被计算为 "first name" 与 "last name" ，而这两个字符串此后可以用来引用对 应属性。使用**方括号表示法**，任何**能放在对象实例方括号内的东西**，都可以作为**需计算属性名**用在对象字面量中。

#### 对象方法

- Object.keys(obj)
  返回一个数组，成员是参数对象自身的（**不含继承的**）所有**可遍历**（enumerable）属性的**键名**。
- Object.values(obj)
  返回一个数组，成员是参数对象自身的（**不含继承的**）所有**可遍历**（enumerable）属性的**键值**
- Object. entries(obj)
  返回一个数组，成员是参数对象自身的（**不含继承的**）所有**可遍历**（enumerable）属性的**键值对数组**。

#### 新的方法

ES 从 ES5 开始就有一个设计意图：**避免创建新的全局函数**，避免在 Object 对象的原型上添加新方法，而是尝试寻找哪些对象应该被添加新方法。因此，对其他对象不适用的新方法就被添加到全局的 Object 对象上。 ES6 在 Object 对象上引入了两个新方法，以便让特定任务更易完成。

##### Object.is() 方法  常与严格相等运算符比较

当在 JS 中要比较两个值时，你可能会使用相等运算符或严格相等运算符。为了避免在比较时**发生强制类型转换**，许多开发者更倾向于使用后者。但**严格相等运算符**也并**不完全准确**，例如，它认为 +0 与 -0 相等，即使这两者在 JS 引擎中有不同的表示；另外 NaN严格相等NaN会返回 false ，因此有必要使用 isNaN() 函数来正确检测 NaN 。

```javascript
console.log(+0 == -0); // true
console.log(+0 === -0); // true
console.log(Object.is(+0, -0)); // false
console.log(NaN == NaN); // false
console.log(NaN === NaN); // false
console.log(Object.is(NaN, NaN)); // true
console.log(5 == 5); // true
console.log(5 == "5"); // true
console.log(5 === 5); // true
console.log(5 === "5"); // false
console.log(Object.is(5, 5)); // true
console.log(Object.is(5, "5")); // false
```

在许多情况下， Object.is() 的结果与严格相等运算符是相同的，仅有的例外是：它会认为 +0 与 -0 不相等，而且 NaN 等于 NaN 。不过仍然没必要停止使用严格相等运算符，选 择 Object.is() ，还是选择相等或严格相等，取决于代码的实际情况。



##### Object.assign() 方法

**混入**（ Mixin ）是在 JS 中组合对象时最流行的模式。在一次混入中，**一个对象会从另一个对象中接收属性与方法**。很多 JS 的库中都有类似下面的混入方法：

```javascript
function mixin(receiver, supplier) {
    Object.keys(supplier).forEach(function(key) {
    receiver[key] = supplier[key];
});
    return receiver;
}
```

mixin() 函数在 supplier对象的自有属性上进行迭代，并将这些属性复制到 receiver 对象（浅复制，当属性值为对象时，仅复制其引用）。这样 receiver 对象就能获得新的属性而无须使用继承，正如下面代码：

```javascript
function EventTarget() { /*...*/ }
EventTarget.prototype = {
    constructor: EventTarget,
    emit: function() { /*...*/ },
    on: function() { /*...*/ }
};

var myObject = {};
mixin(myObject, EventTarget.prototype);

myObject.emit("somethingChanged");
```

此处 myObject 对象接收了 EventTarget.prototype 对象的行为，这给了它分别使用 emit() 与 on() 方法来发布事件与订阅事件的能力。

此模式已经足够流行，于是 ES6 就添加了 Object.assign() 方法来完成同样的行为。该方法**接受一个接收者**，以及**任意数量的供应者**，并会**返回接收者**。方法名称从 mixin() 变更为 assign() 更能反映出实际发生的操作。由于 mixin() 函数使用了**赋值运算符（ = ）**，它就**无法将访问器属性复制到接收者上**， Object.assign() 体现了这种区别。

各式各样的库中都有相似但名称不同的方法，其基本功能相同，流行的替代方法包括 extend() 或 mix() 。而 ES6 也曾在 Object.assign() 之外短暂存在一个 Object.mixin() 方法，二者的主要差异在于 Object.mixin() 也会复制访问器属性，但考虑到 super 的使用（详见本章的“使用 super 引用的简单原型访问”小节），此方法最终被移除了。

Object.assign() 方法并不是 ES6 的一项重大扩展，但它确实**将很多 JS 库中的一个公共方法标准化**了。

#### 重复的对象字面量属性

ES5 严格模式为重复的对象字面量属性引入了一个检查，若找到重复的属性名，就会抛出错误。例如，以下代码就有问题：

```javascript
"use strict";
var person = {
name: "Nicholas",
name: "Greg" // 在 ES5 严格模式中是语法错误
};
```

在 ES5 严格模式下运行时，第二个 name 属性会造成语法错误。但 ES6 移除了重复属性的检查，严格模式与非严格模式都不再检查重复的属性。当存在重复属性时，排在后面的属性的值会成为该属性的实际值

#### 自由属性的枚举属性

ES5 并没有定义对象属性的枚举顺序，而是把该问题留给了 JS 引擎厂商。而 ES6 则严格定义了**对象自有属性在被枚举时返回的顺序**。这对 Object.getOwnPropertyNames() 与 Reflect.ownKeys 如何返回属性造成了影响，还同样影响了 Object.assign() 处理属性的顺序。

自有属性枚举时基本顺序如下：

1. 所有的数字类型键，按升序排列。
2. 所有的字符串类型键，按被添加到对象的顺序排列。
3. 所有的符号类型键，也按添加顺序排列。

```javascript
var obj = {
a: 1,
0: 1,
c: 1,
2: 1,
b: 1,
1: 1
};
obj.d = 1;
console.log(Object.getOwnPropertyNames(obj).join("")); // "012acbd"
```

Object.getOwnPropertyNames() 方法按 0 、 1 、 2 、 a 、 c 、 b 、 d 的顺序返 回了 obj 对象的属性。注意，**数值类型的键会被合并并排序**，即使这未遵循在对象字面量中的顺序。**字符串类型的键会跟在数值类型的键**之后，按照被添加到 obj 对象的顺序，在对象字面量中定义的键会首先出现，接下来是此后动态添加到对象的键。

for-in 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。 而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺序。

虽然枚举顺序的变动对 JS 的工作方式影响甚小，但是依赖于特定枚举顺序才能正确运行的程 序并不罕见。因此 ES6 通过规定枚举的顺序，以确保依赖枚举操作的 JS 代码都能正常工 作，而不用在意其运行环境

#### 更强大的原型

原型是在 JS 中进行继承的基础， ES6 则在继续让原型更强大。早期的 JS 版本对原型的使用 有严重限制，然而随着语言的成熟，开发者也越来越熟悉原型的工作机制，因此他们明显希 望能对原型有更多控制权，并能更方便地使用它。于是 ES6 就给原型引入了一些改进。

##### 修改对象的原型

一般来说，对象的原型会在通过构造器或 Object.create() 方法创建该对象时被指定。

直到 ES5 为止， JS 编程最重要的假定之一就是对象的原型在**初始化完成后**会**保持不变**。

尽管 ES5 添加了 Object.getPrototypeOf() 方法来从任意指定对象中获取其原型，但仍然缺少在初始化之后更改对象原型的标准方法。

ES6 通过添加 Object.setPrototypeOf() 方法而改变了这种假定，此方法**允许你修改任意指定对象的原型**。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。 例如：

```javascript
let person = {
    getGreeting() {
    return "Hello";
    }
};
let dog = {
    getGreeting() {
    return "Woof";
    }
};
// 原型为 person
let friend = Object.create(person);
console.log(friend.getGreeting()); // "Hello"
console.log(Object.getPrototypeOf(friend) === person); // true
// 将原型设置为 dog
Object.setPrototypeOf(friend, dog);
console.log(friend.getGreeting()); // "Woof"
console.log(Object.getPrototypeOf(friend) === dog); // true
```

此代码定义了两个基础对象： person 与 dog ，二者都拥有一个名为 getGreeting() 的方 法，用于返回一个字符串。

friend 对象起初继承了 person 对象，意味着 friend.getGreeting() 方法会输出 "Hello" ；当它的原型被更改为 dog 对象， friend.getGreeting() 方法就会改而输出 "Woof" ，因为原先与 person 的关联已经被破坏了。 对象原型的实际值被存储在一个内部属性 [[Prototype]] 上， Object.getPrototypeOf() 方法会返回此属性存储的值，而 Object.setPrototypeOf() 方法则能够修改该值。不过，使用 [[Prototype]] 属性的方式还不止这些。

##### 使用super引用的简单原型访问

正如前面提到的，原型对 JS 来说非常重要，而 ES6 也进行了很多工作来让它更易用。关于原型的另一项进步就是引入了 super 引用，这让在对象原型上的功能调用变得更容易。例如，若要覆盖对象实例的一个方法、但依然要调用原型上的同名方法，你可能会这么做

```javascript
let person = {
    getGreeting() {
    return "Hello";
    }
};
let dog = {
    getGreeting() {
    return "Woof";
    }
};
let friend = {
    getGreeting() {
    return Object.getPrototypeOf(this).getGreeting.call(this) + ", hi!";
    }
};
// 将原型设置为 person
Object.setPrototypeOf(friend, person);
console.log(friend.getGreeting()); // "Hello, hi!"
console.log(Object.getPrototypeOf(friend) === person); // true
// 将原型设置为 dog
Object.setPrototypeOf(friend, dog);
console.log(friend.getGreeting()); // "Woof, hi!"
console.log(Object.getPrototypeOf(friend) === dog); // true
```

本例中 friend 上的 getGreeting() 调用了对象上的同名方法。 Object.getPrototypeOf() 方法确保了能调用正确的原型，并在其返回结果上附加了一个字符串；而附加的 **call(this)** 代码则能确保正确设置原型方法内部的 this 值。

调用原型上的方法时要记住使用 Object.getPrototypeOf() 与 .call(this) ，这有点复杂难懂，因此 ES6 才引入了 super 。简单来说， **super 是指向当前对象的原型的一个指针**，实际上就是 Object.getPrototypeOf(this) 的值。知道这些，你就可以像下面这样简化

```javascript
let friend = {
    getGreeting() {
    // 这相当于上个例子中的：
    // Object.getPrototypeOf(this).getGreeting.call(this)
    return super.getGreeting() + ", hi!";
    }
};
```

此处调用 super.getGreeting() 等同于在上例的环境中使用 Object.getPrototypeOf(this).getGreeting.call(this) 。类似的，你能使用 super 引用来调用对象原型上的任何方法，只要这个引用是位于简写的方法之内。试图在方法简写之外的情况使用 super 会导致语法错误，正如下例：

```javascript
let friend = {
    getGreeting: function() {
    // 语法错误
    return super.getGreeting() + ", hi!";
    }
};
```

此例使用了一个函数作为**具名方法**，于是调用 super.getGreeting() 就导致了语法错误，因为在这种上下文中 super 是不可用的。 当使用多级继承时， super 引用就是非常强大的，因为这种情况下 Object.getPrototypeOf() 不再适用于所有场景，例如

```javascript
let person = {
    getGreeting() {
    return "Hello";
    }
};
// 原型为 person
let friend = {
    getGreeting() {
    return Object.getPrototypeOf(this).getGreeting.call(this) + ", hi!";
    }
};
Object.setPrototypeOf(friend, person);
// 原型为 friend
let relative = Object.create(friend);
console.log(person.getGreeting()); // "Hello"
console.log(friend.getGreeting()); // "Hello, hi!"
console.log(relative.getGreeting()); // error!
```

调用 Object.getPrototypeOf() 时，在调用 relative.getGreeting() 处发生了错误。这是因为此时 this 的值是 relative ，而 relative 的原型是 friend 对象，这样 friend.getGreeting().call() 调用就会导致进程开始反复进行递归调用，直到发生堆栈错误。 此问题在 ES5 中很难解决，但若使用 ES6 的 super ，就很简单了：

```javascript
let person = {
    getGreeting() {
    return "Hello";
    }
};
// 原型为 person
let friend = {
    getGreeting() {
    return super.getGreeting() + ", hi!";
    }
};
Object.setPrototypeOf(friend, person);
// 原型为 friend
let relative = Object.create(friend);
console.log(person.getGreeting()); // "Hello"
console.log(friend.getGreeting()); // "Hello, hi!"
console.log(relative.getGreeting()); // "Hello, hi!"
```

由于 super 引用并非是动态的，它总是能指向正确的对象。在本例中， super.getGreeting() 总是指向 person.getGreeting() ，而不管有多少对象继承了此方法

### 箭头函数

ES6允许使用“箭头”（=>）定义函数

#### 基本用法

```javascript
var f = v => v;  等价于
var f = function(v) { 
    return v; 
};
```

如果箭头函数**不需要参数**或**需要多个参数**，就使用一个圆括号代表参数部分。

如果箭头函数的代码块部分**多于一条语句**，就要使用**大括号**将它们括起来，并且使用return语句返回。

```javascript
let test = (a, b) => {
    console.log(a + b);
  }
  console.log(test(1, 2));
```

##### 箭头函数的特点

1. 箭头函数不可以作为构造函数  箭头函数不可以作为构造函数  箭头函数不可以作为构造函数
2. 形式上，如果只有一个参数，那么小（圆）括号可以省略
3. 形式上，如果函数的代码块体内只有一句代码，那么大括号也可以省略
4. 没有内部属性arguments 内部没有属性arguments  没有内部属性arguments
5. 内部没有this，this指向的声明的作用域（指向的是上一层作用域的this,此表述并不准确）

#### this的指向

普通函数

```javascript
obj = {
    name: 'amo',
    age: '26',
    sayName() {
        console.log(this);
    }
}
obj.sayName();
//{ name: 'amo', age: '26', sayName: [Function: sayName] }
```

箭头函数

```javascript
obj = {
    name: 'amo',
    age: '26',
    sayName: () => {
        console.log(this);
    }
}
obj.sayName();
//{}
```

ES5中的this，就是调用者

ES6中本身没有this,this指的是声明时候作用域的this,简而言之：调用者的上一层

#### 没有内部属性arguments

```javascript
let test2 = (...temp) => {
    console.log(arguments);
    console.log(temp);
}
test2(1, 2, 3, 4, 5)

//打印结果：
[Arguments] {
  '0': {},
  '1': [Function: require] {
    resolve: [Function: resolve] { paths: [Function: paths] },
    main: Module {
      id: '.',
      path: 'F:\\0000000000前端\\web2005\\ES6\\es6-day02',
      exports: {},
      parent: null,
      filename: 'F:\\0000000000前端\\web2005\\ES6\\es6-day02\\test.js',
      loaded: false,
      children: [],
      paths: [Array]
    },
    extensions: [Object: null prototype] {
      '.js': [Function (anonymous)],
      '.json': [Function (anonymous)],
      '.node': [Function (anonymous)]
    },
    cache: [Object: null prototype] {
      'F:\\0000000000前端\\web2005\\ES6\\es6-day02\\test.js': [Module]
    }
  },
  '2': Module {
    id: '.',
    path: 'F:\\0000000000前端\\web2005\\ES6\\es6-day02',
    exports: {},
    parent: null,
    filename: 'F:\\0000000000前端\\web2005\\ES6\\es6-day02\\test.js',
    loaded: false,
    children: [],
    paths: [
      'F:\\0000000000前端\\web2005\\ES6\\es6-day02\\node_modules',
      'F:\\0000000000前端\\web2005\\ES6\\node_modules',
      'F:\\0000000000前端\\web2005\\node_modules',
      'F:\\0000000000前端\\node_modules',
      'F:\\node_modules'
    ]
  },
  '3': 'F:\\0000000000前端\\web2005\\ES6\\es6-day02\\test.js',
  '4': 'F:\\0000000000前端\\web2005\\ES6\\es6-day02'
}
[ 1, 2, 3, 4, 5 ]
```



### 继承

#### ES5与ES6对比

Class之间通过extends关键字实现继承

ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this

ES5通过修改原型链实现继承

ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）

#### super关键词

表示父类的构造函数，用来新建父类的this对象

子类必须在constructor方法中调用super方法，否则新建实例时会报错

子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工

不调用super方法，子类就得不到this对象

在子类的构造函数中，只有调用super之后，才可以使用this关键字

##### 作为函数调用

代表父类的构造函数，子类的构造函数必须执行一次super函数

作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错

##### 作为对象时，指向父类的原型对象

ES6 规定，通过super调用父类的方法时，super会绑定子类的this

#### Object.getPrototypeOf()

Object.getPrototypeOf方法可以用来从子类上获取父类

#### 原生构造函数的继承

原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。
Boolean()
Number()
String()
Array()
Date()
Function()
RegExp()
Error()
Object()

##### ES6中原生构造函数的继承

ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都

可以继承。下面是一个继承Array的例子

##### ES6的静态方法与静态属性

ES6规定，Class内部只有静态方法，没有静态属性。

静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性

ES7有一个静态属性的提案，目前Babel转码器支持

##### new.target属性

new是从构造函数生成实例的命令。

（在构造函数中）返回new命令作用于的那个构造函数

如果构造函数不是通过new命令调用的，new.target会返回undefined

次属性可以用来确定构造函数是怎么调用的

Class内部调用new.target，返回当前Class

子类继承父类时，new.target会返回子类

在函数外部，使用new.target会报错



### 扩展运算符

##### 一般用法

相当于进行了解构 又重新赋值 访问部分数据（个人类型）

```javascript
console.log(...[1, 2, 3]) // 1 2 3
let arr = ['a', 'b', 'c']
let [...test] = arr
console.log(test)//[ 'a', 'b', 'c' ]

let {...obj } = { name: 'tom', age: 12 }
console.log(obj)//{ name: 'tom', age: 12 }
```

##### 函数的调用(使用频率蛮高)

```javascript
let test = (a, b, c) => {
    console.log(a, b, c)
}
let arr = [1, 2, 3]
test(arr)//[ 1, 2, 3 ] undefined undefined 把arr当做一个整体给a了，b和c得到的值是undefined
test(...arr)//1 2 3 把当前的数组进行了解构，把123单抛出来，分别赋给a,b,c 实际使用比较多
```

##### 将字符串转换为数组

```javascript
let str="hello"
console.log([...str])
//[ 'h', 'e', 'l', 'l', 'o' ]
```

##### 对象中用...(扩展运算符)

```javascript
let obj={
    name:'tom',
    age:12
}

let obj2 = {
    ...obj,
    gender:'male'
}
console.log(obj2)
//{ name: 'tom', age: 12, gender: 'male' } 相当于obj2中也有了obj的属性  相当于把obj合并到了obj2中
```



## 其他js__________________________________________________________________________________________

### Math

##### [Math.round()，Math.ceil()，Math.floor()的区别](https://www.cnblogs.com/johnsonwei/p/6101171.html)

floor方法向下取整，返回小于或等于函数参数，~~取与之最近的整数~~

欠多少钱，没人情味，2:1的转正期，

Math.floor((3/2)) 1

```
document.write(Math.floor(0.60))   0
document.write(Math.floor(0.40))   0
document.write(Math.floor(5))      5
document.write(Math.floor(5.1))    5
document.write(Math.floor(-5.1))   -6
document.write(Math.floor(-5.9))   -6
```

